# LinkLab 报告

姓名：张笑凯
学号：2024201542

## Part A: 思路简述

链接器的核心实现采用多阶段处理流程：

1. **输入处理**：区分普通目标文件和归档文件，对归档文件实现按需链接算法
2. **节合并**：遍历所有目标文件，将同名节的数据和重定位信息合并，记录每个节在合并后的偏移
3. **符号解析**：建立全局符号表和每个目标文件的本地符号表，处理符号冲突（强/弱符号规则）
4. **段布局**：按前缀将节归类到标准输出节（.text/.rodata/.data/.bss），计算4KB对齐的虚拟地址
5. **重定位处理**：根据重定位类型计算并填充正确的地址值
6. **输出生成**：设置节头、程序头和入口点

关键数据结构包括：`merged_sections`存储合并后的节，`global_symbols`管理全局符号，`local_symbols_by_obj`为每个目标文件维护独立的本地符号表，`sec_to_output`和`sec_offset_in_output`记录节的映射关系。

## Part B: 具体实现分析

### 符号解析实现

符号按类型分为三类处理：

1. **本地符号**（以`.`开头）：存储在`local_symbols_by_obj[obj_idx]`中，每个目标文件独立维护。这确保了不同文件中同名的本地符号（如`.LC0`）不会混淆。

2. **全局符号**：存储在`global_symbols`中，遵循以下冲突解决规则：
   - 两个强符号（GLOBAL）冲突时抛出错误
   - 强符号覆盖弱符号（WEAK）
   - 多个弱符号共存，保留第一个
   - 已定义符号覆盖未定义符号（UNDEFINED）

3. **符号偏移更新**：合并节时累加偏移量，确保符号在合并后的节中位置正确。

错误处理包括：检测重复强符号定义、未定义符号引用等。

### 重定位处理

支持四种x86-64重定位类型：

| 类型 | 计算公式 | 用途 |
|------|---------|------|
| R_X86_64_32 | S + A | 32位绝对地址 |
| R_X86_64_32S | S + A（有符号） | 32位有符号绝对地址 |
| R_X86_64_PC32 | S + A - P | 32位PC相对寻址（函数调用） |
| R_X86_64_64 | S + A | 64位绝对地址（指针） |

其中S为符号地址，A为addend，P为重定位位置地址。

对于本地符号的重定位，需要通过重定位偏移范围判断其来源目标文件，然后在对应的本地符号表中查找。关键是使用`merged_sec_vaddr`映射来计算本地符号所在merged section的正确虚拟地址。

错误处理包括：检查32位重定位是否溢出、偏移是否越界。

### 段合并策略

采用前缀匹配的合并策略：

1. **分类规则**：
   - `.text*` → `.text`（代码段）
   - `.rodata*` → `.rodata`（只读数据段）
   - `.data*` → `.data`（可读写数据段）
   - `.bss*` → `.bss`（未初始化数据段）
   - 其他 → `.data`

2. **内存布局**：
   - 基地址：0x400000
   - 每个段按4KB（PAGE_SIZE）对齐
   - 段顺序：.text → .rodata → .data → .bss

3. **特殊处理**：
   - `.bss`段在文件中不占空间（file_offset=0），但在内存中分配空间
   - 文件偏移紧密排列，不需要页对齐
   - 静态可执行文件在重定位处理后清除relocs信息

## Part C: 关键难点解决

### 难点1：本地符号的跨文件重定位

**问题描述**：本地符号（如`.rodata.str1.1`、`.LC0`）在不同目标文件中可能同名但指向不同数据。重定位时需要找到正确的符号定义。

**解决方案**：
1. 为每个目标文件维护独立的本地符号表`local_symbols_by_obj`
2. 处理重定位时，通过偏移范围判断重定位来自哪个目标文件
3. 在对应目标文件的本地符号表中查找符号

```cpp
// 通过偏移范围判断重定位来源
for (size_t obj_idx = 0; obj_idx < all_objects.size(); obj_idx++) {
    if (reloc_offset_in_merged >= start_offset && 
        reloc_offset_in_merged < start_offset + size) {
        // 在该目标文件的本地符号表中查找
        auto local_sym_it = local_symbols_by_obj[obj_idx].find(reloc.symbol);
        ...
    }
}
```

### 难点2：符号节名映射与虚拟地址计算

**问题描述**：符号的原始section名（如`.rodata.str1.1`）需要映射到输出section名（如`.rodata`），且需要正确计算在输出节中的偏移。

**解决方案**：
1. 创建`merged_sec_vaddr`映射，记录每个merged section的虚拟地址
2. 在重定位前更新`global_symbols`中符号的section和offset
3. 使用辅助函数`get_output_section_name()`进行前缀匹配

```cpp
// 创建 merged section 到虚拟地址的映射
for (const auto& [sec_name, _] : merged_sections) {
    std::string out_sec = get_output_section_name(sec_name);
    merged_sec_vaddr[sec_name] = section_vaddr_offsets[out_sec] + sec_offset_in_output[sec_name];
}
```

### 难点3：静态库的按需链接

**问题描述**：静态库中可能包含大量目标文件，但程序只使用其中一部分。需要实现按需提取。

**解决方案**：
1. 维护`resolved_symbols`和`undefined_symbols`两个集合
2. 迭代扫描归档文件，提取能解析未定义符号的成员
3. 循环直到没有新符号被解析

## Part D: 实验反馈

### 实验设计
- **难度**：难度适中，任务逐步递进，从简单的符号表查看到复杂的重定位处理
- **工作量**：合理，约15小时完成主要任务
- **收获**：深入理解了链接器的工作原理，特别是符号解析和重定位的细节

### 实验文档
- 文档整体清晰，FLE格式的设计降低了学习ELF的门槛
- 建议：可以增加更多关于本地符号处理的说明，这是一个容易踩坑的地方

### 框架代码
- 框架设计合理，`readfle`工具对调试帮助很大
- `exec`模拟执行器便于测试，无需真实运行二进制文件
- 建议：可以提供更详细的错误信息，帮助定位问题

## 参考资料

1. 实验文档 - FLE格式定义和任务说明
2. System V ABI - x86-64重定位类型定义
3. CSAPP第7章 - 链接的基本概念